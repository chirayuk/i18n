{"version":3,"sources":["lib/placeholderRegistryHints.es6"],"names":[],"mappings":";;AAAA,IAAI,aAAa,GAAG,OAAO,CAAC,iBAAiB,CAAC,CAAC;;AAE/C,IAAI,qBAAqB,GAAG,OAAO,CAAC,uCAAuC,CAAC,CAAC,qBAAqB,CAAC;;AAEnG,SAAS,yBAAyB,CAAC,WAAW,EAAE;AAC9C,MAAI,WAAW,YAAY,aAAa,CAAC,OAAO,EAAE;AAChD,QAAI,QAAQ,GAAG,WAAW,CAAC,iBAAiB,EAAE,CAAC;AAC/C,YAAQ,QAAQ;AACd,WAAK,aAAa,CAAC,sBAAsB;AACvC,eAAO,qBAAqB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;AAAA,AAChD;;;;;AAKE,cAAM,KAAK,0DAAuD,QAAQ,iCAA6B,CAAC;AAAA,KAC3G;GACF,MAAM;AACL,WAAO,AAAC,WAAW,YAAY,aAAa,CAAC,MAAM,GAAI,YAAY,GAAG,IAAI,CAAC;GAC5E;CACF;;AAED,MAAM,CAAC,OAAO,CAAC,yBAAyB,GAAG,yBAAyB,CAAC","file":"lib/placeholderRegistryHints.js","sourcesContent":["var message_types = require(\"./message_types\");\n\nvar getNameHintForHtmlTag = require(\"./placeholderRegistryHintsForHtmlTags\").getNameHintForHtmlTag;\n\nfunction getNameHintForPlaceholder(placeholder) {\n  if (placeholder instanceof message_types.TagPair) {\n    var typeName = placeholder.getStableTypeName();\n    switch (typeName) {\n      case message_types.TYPENAME_HTML_TAG_PAIR:\n        return getNameHintForHtmlTag(placeholder.tag);\n      default:\n        // NOTE: If/When we support different tag types, we want to come up with\n        // a sane system of naming the generated placeholders instead of\n        // generating one automatically here.  By throwing an error here, we\n        // force ourselves to revisit this code and pick a good naming scheme.\n        throw Error(`InternalError: Placeholder hints for tags of type \"${typeName}\" are not yet implemented.`);\n    }\n  } else {\n    return (placeholder instanceof message_types.NgExpr) ? 'EXPRESSION' : 'PH';\n  }\n}\n\nmodule.exports.getNameHintForPlaceholder = getNameHintForPlaceholder;\n"]}